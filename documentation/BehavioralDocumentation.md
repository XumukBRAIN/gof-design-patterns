# Поведенческие паттерны проектирования

## Оглавление
- [Введение](#введение)
- [Список паттернов](#список-паттернов)
  - [1. Command](#1-command)
  - [2. Iterator](#2-iterator)
  - [3. Observer](#3-observer)
  - [4. State](#4-state)
  - [5. Strategy](#5-strategy)
  - [6. Template Method](#6-template-method)
  - [7. Visitor](#7-visitor)
  - [8. Memento](#8-memento)
  - [9. Chain of Responsibility](#9-chain-of-responsibility)
  - [10. Mediator](#10-mediator)
  - [11. Interpreter](#11-interpreter)

## Введение
Поведенческие паттерны проектирования определяют, как объекты взаимодействуют и общаются друг с другом. Эти паттерны помогают упростить сложные взаимодействия между объектами и делают код более гибким и поддерживаемым.

## Список паттернов

### 1. Command
- **Описание**: Инкапсулирует запрос как объект, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь или регистрировать их.
- **Пример**: Умный дом, где команды (включить свет, включить музыку) инкапсулируются в объекты.
- **Плюсы**:
  - Упрощает реализацию отмены и повторного выполнения операций.
  - Позволяет параметризовать методы с различными командами.
- **Минусы**:
  - Увеличивает количество классов в проекте.

### 2. Iterator
- **Описание**: Предоставляет способ последовательного доступа к элементам агрегированного объекта без раскрытия его внутренней структуры.
- **Пример**: Итератор для обхода элементов коллекции книг.
- **Плюсы**:
  - Упрощает обход сложных структур данных.
  - Позволяет создавать разные итераторы для одной и той же коллекции.
- **Минусы**:
  - Увеличивает количество классов в проекте.

### 3. Observer
- **Описание**: Определяет зависимость "один ко многим" между объектами, так что когда один объект изменяет свое состояние, все его зависимые объекты уведомляются и обновляются.
- **Пример**: Система уведомлений о погоде, где дисплеи получают обновления от метеостанции.
- **Плюсы**:
  - Упрощает взаимодействие между объектами с помощью слабой связи.
  - Позволяет динамически добавлять или удалять наблюдателей.
- **Минусы**:
  - Может привести к сложной системе при большом количестве наблюдателей.

### 4. State
- **Описание**: Позволяет объекту изменять свое поведение в зависимости от своего внутреннего состояния, избегая сложных условных операторов.
- **Пример**: Музыкальный плеер с состояниями "Воспроизведение", "Пауза" и "Остановлено".
- **Плюсы**:
  - Упрощает управление состоянием объектов.
  - Позволяет добавлять новые состояния без изменения существующего кода.
- **Минусы**:
  - Увеличивает количество классов в проекте.

### 5. Strategy
- **Описание**: Позволяет определить семейство алгоритмов, инкапсулировать их и сделать их взаимозаменяемыми, что позволяет изменять алгоритм независимо от клиентов, которые его используют.
- **Пример**: Система сортировки с различными стратегиями (сортировка пузырьком и сортировка выбором).
- **Плюсы**:
  - Упрощает добавление новых алгоритмов без изменения существующего кода.
  - Уменьшает количество условных операторов.
- **Минусы**:
  - Увеличивает количество классов в проекте.

### 6. Template Method
- **Описание**: Определяет скелет алгоритма в методе, оставляя реализацию некоторых шагов подклассам, что позволяет переопределять определенные шаги алгоритма без изменения его структуры.
- **Пример**: Приготовление напитков (чай и кофе) с общим процессом приготовления.
- **Плюсы**:
  - Упрощает поддержку и расширение кода.
  - Гарантирует выполнение общего алгоритма в правильном порядке.
- **Минусы**:
  - Может привести к созданию большого количества подклассов.

### 7. Visitor
- **Описание**: Позволяет добавлять новые операции к объектам без изменения их классов, разделяя алгоритмы от объектов, над которыми они работают.
- **Пример**: Посетитель для элементов графического интерфейса (кнопки и текстовые поля).
- **Плюсы**:
  - Позволяет добавлять новые операции без изменения классов объектов.
  - Упрощает работу с комплексными структурами объектов.
- **Минусы**:
  - Увеличивает количество классов в проекте.

### 8. Memento
- **Описание**: Позволяет сохранять и восстанавливать состояние объекта без нарушения инкапсуляции, что полезно для реализации функциональности отмены.
- **Пример**: Редактор текста с возможностью сохранения и восстановления состояния текста.
- **Плюсы**:
  - Позволяет сохранять состояние без нарушения инкапсуляции.
  - Упрощает реализацию функциональности отмены.
- **Минусы**:
  - Может потреблять много памяти при сохранении множества состояний.

### 9. Chain of Responsibility
- **Описание**: Позволяет передавать запросы по цепочке обработчиков, избегая жесткой привязки между отправителем и получателем.
- **Пример**: Обработка запросов на кредит в банке через цепочку проверок (кредитная история, доход).
- **Плюсы**:
  - Позволяет динамически изменять обработчиков на этапе выполнения.
  - Упрощает добавление новых обработчиков в цепочку.
- **Минусы**:
  - Может привести к проблемам с производительностью при длинных цепочках.

### 10. Mediator
- **Описание**: Определяет объект-посредник, который управляет взаимодействием между множеством объектов, уменьшая их зависимость друг от друга.
- **Пример**: Чат-комната, где пользователи общаются через посредника (чат-систему).
- **Плюсы**:
  - Упрощает взаимодействие между объектами с помощью слабой связи.
  - Централизует управление взаимодействиями.
- **Минусы**:
  - Может стать сложным при большом количестве объектов и логики.

### 11. Interpreter
- **Описание**: Определяет грамматику языка и интерпретирует его предложения. Полезен для разбора и выполнения выражений на основе заранее определенной структуры.
- **Пример**: Арифметический калькулятор, который интерпретирует выражения вроде `5 + 3`.
- **Плюсы**:
  - Упрощает добавление новых правил и грамматик.
  - Хорошо подходит для реализации простых языков.
- **Минусы**:
  - Неэффективен для сложных грамматик.
  - Может привести к созданию большого количества классов.

## Заключение
Эти поведенческие паттерны проектирования помогают упростить взаимодействие между объектами и делают код более чистым и поддерживаемым. Изучение и применение этих паттернов может значительно улучшить архитектуру ваших приложений.

